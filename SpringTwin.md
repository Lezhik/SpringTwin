# Spring Twin

## Слоган

Понимай архитектуру. Управляй сложностью.

---

# 1. Общее описание проекта

Spring Twin — MCP-агент для анализа Spring Boot проектов с построением архитектурного графа и формированием контекстных отчетов для использования совместно с Cloud LLM.

Проект не является полноценным цифровым двойником на текущем этапе, однако закладывает архитектурный фундамент для дальнейшего развития в этом направлении.

Основная цель MVP — извлечение структурированного архитектурного контекста проекта и формирование explain-отчетов через веб-интерфейс и MCP-интеграции.

---

# 2. Цели MVP

1. Индексация Spring Boot проекта.
2. Построение графа зависимостей (DI-граф).
3. Расширение графа связями на основе анализа байткода.
4. Формирование explain-отчетов:
   - по endpoint
   - по классу
   - по методу
5. Экспорт структурированного контекста для Cloud LLM.
6. Веб-интерфейс для анализа и генерации отчетов.
7. Интеграция с Cursor AI и Kilo Code.

---

# 3. Область анализа (Scope)

## 3.1 Индексация исходного кода

- Анализ Java AST
- Обнаружение аннотированных компонентов:
  - Controller
  - RestController
  - Service
  - Repository
  - Component
  - Configuration
  - Bean
- Определение зависимостей через constructor injection

## 3.2 Анализ байткода

- Анализ .class файлов после сборки
- Добавление в граф следующих типов связей:
  - Field reference
  - Method invocation
  - Object instantiation
- Фильтрация классов по include/exclude маске пакетов

## 3.3 Ограничение области анализа

Агент должен поддерживать конфигурацию:

- includePackages
- excludePackages

Фильтрация применяется ко всем этапам индексирования.
Внешние библиотеки не индексируются.

---

# 4. Графовая модель (высокоуровнево)

## Узлы:
- Class
- Method
- Endpoint

### Использование меток (Labels)

Для узлов графа (в первую очередь Class) используются метки (labels) Neo4j.

В рамках MVP метки формируются на основе Spring-аннотаций:
- Controller
- RestController
- Service
- Repository
- Component
- Configuration

Каждый класс может иметь несколько меток.

Метки используются для:
- Фильтрации в explain-отчетах
- Формирования архитектурных срезов
- Подготовки к анализу аномалий

В последующих фазах развития планируется расширение системы меток за счет определения стандартных архитектурных шаблонов и ролей, таких как:
- Factory
- Event
- Listener
- Adapter
- Facade
- Utility

Механизм меток должен быть расширяемым без изменения базовой модели графа.

## Связи:
- DEPENDS_ON (DI)
- CALLS
- INSTANTIATES
- ACCESSES_FIELD
- EXPOSES_ENDPOINT

Граф должен быть расширяемым для будущих фаз (анализ аномалий, security, transactional boundaries).

---

# 5. Explain-отчеты

Система должна поддерживать:

1. Explain endpoint
2. Explain class
3. Explain method

Отчет включает:
- Краткое описание роли элемента
- Зависимости
- Используемые компоненты
- Связанные классы
- Конфигурационные элементы (при наличии)

Формат отчета:
- Читаемый веб-отчет
- JSON-структура для передачи в LLM

---

# 6. MCP-интеграция

Spring Twin предоставляет MCP tools для:

- Получения контекста endpoint
- Получения контекста класса
- Получения контекста метода

Интеграции:
- Cursor AI
- Kilo Code

---

# 7. Архитектура приложения

## Backend
- Java
- Spring Boot 4.x
- WebFlux
- Neo4j (хранение графа зависимостей)

### Хранение графа

- Основное хранилище связей — Neo4j
- В рамках MVP используется только in-memory режим
- Поддержка standalone Neo4j сервера откладывается на последующие фазы развития
- Конфигурация минимизирована для упрощения запуска pet-проекта

Ответственность backend:
- Индексация проекта
- Построение и обновление графа
- Синхронизация с Neo4j
- Генерация отчетов
- MCP API

## Хранение текстовых embeddings

В рамках MVP поддержка embeddings отсутствует.

Функциональность семантического поиска и хранение embeddings откладываются на последующие фазы развития проекта.

## Frontend
- TypeScript
- Vue.js

Функциональность frontend:
- Управление конфигурацией include/exclude
- Настройка режима Neo4j (embedded / standalone)
- Запуск индексации
- Просмотр графа
- Генерация explain-отчетов

## Сборка
- Gradle (Kotlin DSL)
- Единый процесс сборки backend и frontend

---

# 8. Тестирование

## Backend
- JUnit — unit тесты

## Frontend
- Vitest — unit тесты

## E2E
- Cypress — end-to-end тестирование веб-интерфейса

---

# 9. Вектор развития

После MVP возможное развитие:

- Детекция архитектурных аномалий
- Анализ транзакционных границ
- Анализ security-потоков
- Расширенный call graph
- Частичный runtime-анализ
- Кластеризация проекта (выделение логических модулей и bounded context на основе графа связей)
- Поддержка сценариев архитектурного и структурного рефакторинга на основе анализа графа

---

# 10. Нефункциональные требования

- Масштабируемость для проектов среднего размера
- Кэширование индекса
- Повторяемость результатов анализа
- Возможность поэтапного расширения графовой модели

---

Spring Twin — инструмент архитектурного понимания, который сокращает дистанцию между кодовой базой и LLM-анализом.

