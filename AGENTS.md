# AGENTS.md: Регламент разработки проекта SpringTwin MCP

Данный документ определяет технологический стек, стандарты качества кода и итерационный цикл разработки, а так же правила использования базы знаний (специализированного MCP агента, заменяющего memory bank).

---

## О проекте

Sping Twin — MCP-агент для анализа Spring Boot проектов с построением архитектурного графа и формированием контекстных отчетов для использования совместно с Cloud LLM

---

## Технологический стек

- Backend: Java 21+ / Spring Boot 3.x / WebFlux, язык Java (не Kotlin)
- Архитектура: Модульный монолит (Spring Modulith)
- Database: Neo4j
- Frontend: npm 11+, node 24+, Vue.js (компилируется в обычный JavaScript, для хостинга всех статических ресурсов используется Spring Boot)
- Архитектура UI: SPA, модули, такое же разбиение на модули как и на backend, те же модули, с теми же именами
- Сборка: Gradle 8.5+/Kotlin, в том числе для TypeScript (Kotlin используется только для сборки)
- Тесты: Junit для unit тестов на бэкенд, Vitest для unit тестов на frontend, Cypress для e2e тестов, интеграция Cypress со Spring Boot через testcontainers

---

## CLI

локально при разработке используется операционная система windows, используй команды для windows (bat файлы итп)
сборка: gradlew.bat build
очистка и сборка: gradlew.bat clean build
выполнение тестов: gradlew.bat test
выполнение тестов для конкретного модуля: gradlew.bat :module-name:test

---

## Структура проекта

Структура проекта оптимизирована под одиночную разработку проекта в режиме solo vibe coding.

- Проект организован как модульный монолит с использованием Spring Modulith
- Разбивка на модули должна идти по доменам/функционалу но не по слоям
- Исходный код на верхнем уровне разбивается сначала по модулям и только модули уже внутри разбиваются по слоям
- Код TypeScript должен храниться в стандартной для Spring Boot структуре: src/main/vue и src/test/vue
- Скомпилированные JS файлы (из TypeScript) должны помещаться в resources/public/js в папке build/
- Статические ресурсы из Vue.js (<module>/asset/) помещаются в resources/public/<module>/asset в папке build/

---

## Тесты

- Используй тестовые профили для заполнения данных, вместо прямого заполнения данных в тестах, чтобы повторно использовать данные в различных тестах. 
- В качестве профилей будут выступать специальные классы, заполнющие соотсветствующие модели и DTO.
- Все API методы сервисов бизнес-логики должны покрываться unit тестами
- Все методы контроллеров должны покрываться end-to-end тестами
- При end-to-end тестов мы заполняем данные в БД и проверяем отобржаение в UI с помошью cypress
- Используй имена и роли в качестве семантических селекторов в cypress тестах
- При исправлении ошибок, нужно добавлять автотесты на найденные ошибочные сценарии
- Пиши тесты до реализации логики, используй TDD
- Всегда запускай выполнение тестов, после выполнения задачи, чтобы удостоверится, что задача выполнена правильно

---

## Spring Boot

- Применение принципов SOLID при разработке
- Использовать реактивный стэк, все методы должны возвращать Mono/Flux
- Базовый пакет: twin.spring
- Полный пакет: twin.spring.<module>.<layer>
- Использовать lombok аннотации, где они допустимы
- Используй Sl4j lombok аннотацию для логирования
- Используй lombok Builder аннотацию для моделей и DTO. используй методы Builder-а для инициализации моделей и DTO.
- Используй lombok аннотации NoArgsConstructor и AllArgsConstructor для моделей и DTO, чтобы поддерживать Builder и конструктор по умолчанию
- Используй lombok аннотацию RequiredArgsConstructor и модификаторы final для полей для работы с DI в Spring Boot (для контроллеров, сервисов и прочих компонентов)
- Использовать Spring Boot аннотации, где они допустимы
- Имена классов, полей, методов и переменных должны соответствовать правилам семантической разметки, код должен быть самодокументируемым
- Используй суффиксы в именах классов, которые описывают роль класса
- Используй развернутые значения суффиксов, например:
  AggregateService (Сервис-агрегатор данных), 
  DomainService (Бизнес-логика предметной области),
  ApplicationService (Координация use cases)
- Обязательно заполнять JavaDoc для классов и методов
- Для доступа к БД использовать ReactiveNeo4jRepository, работа с БД так же должна быть реактивной через Mono/Flux
- Использовать DTO объекты для запросов и ответов. При этом для запросов и ответов должны использоваться различные классы, даже при совпадении полей.
- DTO должны использовать одинаковые названия полей для ответов в различных классах (name, url итп), для унификации обработки. 
- Использовать специальные Mapper классы для преобразования моделей в DTO и обратно
- Преобразование между моделями и DTO должно происходить в сервисах

---

## Vue.js

- Применение принципов SOLID при разработке
- Используй Vuex для управления состоянием UI
- Имена классов, полей, методов и переменных должны соответствовать правилам семантической разметки, код должен быть самодокументируемым
- Каждый модуль должен иметь отдельное пространство состояний/свой контекст, получаемый из глобального
- Для каждого модуля и его контекста задается свое пространство имен
- Глобальное пространство имен, общее для модулей идет с префиксом app
- Используй асинхронную обработку событий, так как используется реактивный стэк технологий
- Каждый модуль должен покрываться unit тестами
- структура каталогов аналогично backend: в src/main/vue сначала идут папки с модулями (src/main/vue/<module>), а внутри них уже идут слои:
  asset/ - статические файлы: css, шрифты, картинки
  view/ - шаблоны отображения
  store/ - хранилище данных
  router/ - маршрутизация
  service/ - сервисы
  api/ - api 
- корневое приложение рассматриваем как модуль app
- используй семантические значения для атрибутов name и role, для значимых эдементов

---

## Neo4j

- В стартовом варианте используется Neo4j embedded
- Должна быть настройка в application.yml чтобы заменить Neo4j embedded на отдельный Neo4j сервер
- выноси миграции Neo4j в отдельный модуль, внутри модуля пакеты будут соответствовать версиям миграций: code.alchemist.<module>.<version aka v0001> внутри пакета классы миграций, 
  имена которых соответствуют мигрируемым сущностям + суффикс Migration
- Настрой автозапуск миграций при запуске приложения
- Узлами в БД выступают классы, а связями использование одного класса другим, явное или через DI в Spring Boot
- Должны сохраняться информации по связям: имена полей, методов, имена аргументов методов
- Структура базы должна быть оптимизированна под кластеризацию данных

---

## База знаний

База знаний - это замена memory bank. Используется в качестве долгосрочной памяти для передачи контекста задачи в Cloud LLM системы.
В качестве базы знаний используется mem0 - the memory layer for personalized ai. Каждый раз когда в запросе идет указание на обращение к базе знаний 
или когда требуется получение дополнительной информации по проекту, нужно обращаться к mem0.

---

## Задачи

- Задачи дожны быть минималистичного размера с минимальным содержанием функционала. Принцип одной ответственности как в SOLID. 
- Задачи храняться в базе знаний проекта (mem0)
- Все задачи обязательно должны содержать: тесты, критерии приемки и mermaid диаграммы как часть постановки задач

### Постановка задачи
- Название задачи
- Дата создания задачи
- Статус задачи: Новая, В разработке, На проверке, Выполнена, Отклонена
- Текстовое описание
- Ссылки на статьи в базе знаний (mem0)
- Mermaid диаграмма сценария.
- Определение DTO (Request/Response отдельно).
- Описание тестовых сценариев для приемки задачи, включая тестовые данные, для заполнения тестовых профилей и данных, отображаемых на экране
- Критерии приемки задачи

### Этапы реализации

Этапы разработки заточены под TDD. Разработка ведется с акцентом на автоматическое тестирование проекта.

1. **API с заглушками** - Реализация эндпоинтов без логики, API компонентов в UI без реализации
2. **Заполнение тестовых профилей** - Реализация классов с тестовыми профилями, заполняющих БД и DTO объекты
3. **Тестирование** - Unit-тесты логики + E2E тесты
4. **Реализация логики** - Замена заглушек, внедрение мапперов и сервисов
5. **Реализация интерфейса** - Реализация UI компонентов, интеграция компонентов с backend, размещение компонентов на странице
6. **Верификация** - Запуск тестов, исправление замечаний. Этап не считается выполненым, пока все тесты не пройдут
7. **Обновление базы знаний** - Журналируем в базе знаний все внесенные изменения: архитекурные изменения, список измененных файлов, новые компоненты и методы, текстовое описание изменений (mem0)
8. **Code review** - Автоматическое и ручное. Пока пользователь не даст свое подтверждение, задача не считается выполненной
9. **Обовление статуса задачи** - Помечаем задачу в базе знаний как выполненную (mem0)